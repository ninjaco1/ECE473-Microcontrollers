Inclass Exercise (makefiles)

This exercise will help you understand how makefiles work and how
they can make your life much easier as your project gets bigger.
The bottom line is that the more automation that we can employ
we can be more efficient with time and avoid mistakes.

A well written makefile can be reused with few changes if you
think ahead. We will be using a makefile to build all our projects
all the makefiles will look very much the same.

Makefiles are the underlying mechanism in most IDEs but are hidden
from your view. If the tool builds them wrong, you are toast. If you
write your own and understand how it works, you stay in control.

First, download the tarfile:
  wget http://web.engr.oregonstate.edu/~traylor/ece473/inclass_exercises/makefiles/makefiles2/inclass_exercise.tar
  OR
  curl -o inclass_exercise.tar http://web.engr.oregonstate.edu/~traylor/ece473/inclass_exercises/makefiles/makefiles2/inclass_exercise.tar
Untar it into a temporary working area.
  tar xvf inclass_exercise.tar

Answer the questions below on the blank lines. Keep the questions intact 
by copying and editing your local copy of this file.

Fill in the blanks and submit this just this file via Canvas  
by the end of day (5pm).

All the component files that constitute the executable "edit" will be in 
the directory as well as the makefile. In the directions that follow,
the default c compiler in Linux, "cc", is used instead of the c compiler 
for the AVR "avr-gcc". The difference is of no consequence.

Using the given makefile..., 

1. List the series of instructions that would be executed and output to 
   the screen by make if the makefile had never been run to create the 
   executable "edit". On each line tell what is happening. If you are 
   not sure what is being done, type "make clean", followed by "make". 
   The commands executed by make will be transcripted to the shell.

   The command that you would type in is "make edit". 

   cc    -c -o main.o main.c // this line is compiling main.c and making an object file.
   cc    -c -o kbd.o kbd.c   // this line is compiling kbd.c and making an object file.
   cc    -c -o command.o command.c // this line is compiling command.c and making an object file.
   cc    -c -o display.o display.c // this line is compiling display.c and making an object file.
   cc    -c -o insert.o insert.c // this line is compiling insert.c and making an object file.
   cc    -c -o search.o search.c // this line is compiling search.c and making an object file.
   cc    -c -o files.o files.c // this line is compiling files.c and making an object file.
   cc    -c -o utils.o utils.c // this line is compiling util.c and making an object file.
   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o // links all the object files 
   together and put in one file name edit.



2. After successfully doing a "make", i.e., all the files are up to date,
   suppose that command.h was edited. If make is executed again, what
   commands would be executed?  
   
   It will execute the command.o like in the the Makefile and then it would link all the files again.
   cc    -c -o command.o command.c
   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o


   

   You can check your answer easily. First, check the timestamp on all 
   your .c or .h files using "ls" with "time-style" modified to return 
   the time stamp down to the second or fraction of a second.
     ls -l --full-time 
   Note that all the *.o files have a newer (later) timestamp than the 
   .c or .h files. This tells "make" that the .o files are up to date. 
   Also note all the *.o files were created in the same second.

   Now type "touch command.h" to modify the time stamp on command.h.
   Execute the "ls" command again and note the different timestamp on
   command.h. Since command.h is newer than the files that depend on
   it (files.o, command.o, kbd.o), those files must be recreated by
   compiling the corresponding *.c files.

   So when make is run again, we should see the files that depended
   on command.h recompiled, followed by the link.

3. Now suppose that all the files were up to date and then utils.c was 
   touched and make executed. What commands would be executed by make?


   Since that the timestamp changed on the file, the terminal thinks there was a change to it. Then
   when running making it will compile that file target file as long as the the link command.
   cc    -c -o utils.o utils.c
   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

4. Replace the hard tab in the second line of the rule:
   edit : $(OBJECTS)
         cc -o edit $(OBJECTS)
   with 8 spaces instead. Then run make. What does make report?

  The command creates and error.
  Makefile:4: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.


  You might want to remember this result when you forget to use tabs!
  Fix the error and rerun make. What does make then report?

   By doing this the Makefile execute correctly.
   make: 'edit' is up to date.

5. How many files do you see now in your directory?

  there are 22 files in the directory.

   The easy to check this is: "ls | wc -l"
   This lists the files, pipes the result to "word count" and word count
   reports the the number of lines, words, and bytes present. The -l
   switch on wc has it only report lines.

   Type make clean.  You can see what the pseudo target "clean" does.
   Now, how many files are there in your directory?

   There are 13 files after running make clean.

   What types of files were removed? Look at the transcript for hints.

   All the *.o files and edit were removed.


-------- The given Makefile is shown below ----------------------------

OBJECTS = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
     
edit : $(OBJECTS)
	cc -o edit $(OBJECTS)
     
main.o    : defs.h
files.o   : defs.h buffer.h command.h
command.o : defs.h command.h
kbd.o     : defs.h command.h
display.o : defs.h buffer.h
insert.o  : defs.h buffer.h
search.o  : defs.h buffer.h
utils.o   : defs.h
clean     :
	rm edit $(OBJECTS)

